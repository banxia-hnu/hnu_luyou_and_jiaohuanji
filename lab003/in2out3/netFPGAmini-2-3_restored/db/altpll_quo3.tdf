--altpll bandwidth_type="AUTO" CBX_DECLARE_ALL_CONNECTED_PORTS="OFF" clk0_divide_by=1 clk0_duty_cycle=50 clk0_multiply_by=1 clk0_phase_shift="833" clk1_divide_by=1 clk1_duty_cycle=50 clk1_multiply_by=2 clk1_phase_shift="0" clk2_divide_by=1 clk2_duty_cycle=50 clk2_multiply_by=2 clk2_phase_shift="0" clk3_divide_by=1 clk3_duty_cycle=50 clk3_multiply_by=2 clk3_phase_shift="-1250" clk4_divide_by=1 clk4_duty_cycle=50 clk4_multiply_by=2 clk4_phase_shift="0" clk5_divide_by=1 clk5_duty_cycle=50 clk5_multiply_by=2 clk5_phase_shift="0" device_family="Arria II GX" inclk0_input_frequency=10000 intended_device_family="Arria II GX" operation_mode="no_compensation" pll_type="LEFT_RIGHT" port_clk0="PORT_USED" port_clk1="PORT_USED" port_clk2="PORT_USED" port_clk3="PORT_USED" port_clk4="PORT_USED" port_clk5="PORT_USED" port_clk6="PORT_UNUSED" port_clk7="PORT_UNUSED" port_clk8="PORT_UNUSED" port_clk9="PORT_UNUSED" port_inclk1="PORT_UNUSED" port_phasecounterselect="PORT_USED" port_phasedone="PORT_USED" port_scandata="PORT_UNUSED" port_scandataout="PORT_UNUSED" self_reset_on_loss_lock="OFF" using_fbmimicbidir_port="OFF" vco_frequency_control="MANUAL_PHASE" vco_phase_shift_step=104 width_clock=7 areset clk inclk locked phasecounterselect phasedone phasestep phaseupdown scanclk CARRY_CHAIN="MANUAL" CARRY_CHAIN_LENGTH=48
--VERSION_BEGIN 16.0 cbx_altclkbuf 2016:07:21:01:48:15:SJ cbx_altiobuf_bidir 2016:07:21:01:48:16:SJ cbx_altiobuf_in 2016:07:21:01:48:16:SJ cbx_altiobuf_out 2016:07:21:01:48:16:SJ cbx_altpll 2016:07:21:01:48:16:SJ cbx_cycloneii 2016:07:21:01:48:16:SJ cbx_lpm_add_sub 2016:07:21:01:48:16:SJ cbx_lpm_compare 2016:07:21:01:48:16:SJ cbx_lpm_counter 2016:07:21:01:48:16:SJ cbx_lpm_decode 2016:07:21:01:48:16:SJ cbx_lpm_mux 2016:07:21:01:48:16:SJ cbx_mgl 2016:07:21:01:49:21:SJ cbx_nadder 2016:07:21:01:48:16:SJ cbx_stratix 2016:07:21:01:48:16:SJ cbx_stratixii 2016:07:21:01:48:16:SJ cbx_stratixiii 2016:07:21:01:48:16:SJ cbx_stratixv 2016:07:21:01:48:16:SJ cbx_util_mgl 2016:07:21:01:48:16:SJ  VERSION_END


-- Copyright (C) 1991-2016 Altera Corporation. All rights reserved.
--  Your use of Altera Corporation's design tools, logic functions 
--  and other software and tools, and its AMPP partner logic 
--  functions, and any output files from any of the foregoing 
--  (including device programming or simulation files), and any 
--  associated documentation or information are expressly subject 
--  to the terms and conditions of the Altera Program License 
--  Subscription Agreement, the Altera Quartus Prime License Agreement,
--  the Altera MegaCore Function License Agreement, or other 
--  applicable license agreement, including, without limitation, 
--  that your use is for the sole purpose of programming logic 
--  devices manufactured by Altera and sold by Altera or its 
--  authorized distributors.  Please refer to the applicable 
--  agreement for further details.


FUNCTION altpll_dyn_phase_le_jdo (dataa, datab, datac, datad)
RETURNS ( combout);
FUNCTION altpll_dyn_phase_le_kdo (dataa, datab, datac, datad)
RETURNS ( combout);
FUNCTION altpll_dyn_phase_le_ldo (dataa, datab, datac, datad)
RETURNS ( combout);
FUNCTION altpll_dyn_phase_le_mdo (dataa, datab, datac, datad)
RETURNS ( combout);
FUNCTION lcell (in)
RETURNS ( out);
FUNCTION cntr_hud (clock, cnt_en)
RETURNS ( q[1..0]);
FUNCTION cntr_nce (aclr, clock, cnt_en)
RETURNS ( q[2..0]);
FUNCTION arriaii_pll (areset, clkswitch, configupdate, fbin, inclk[1..0], pfdena, phasecounterselect[phasecounterselect_width-1..0], phasestep, phaseupdown, scanclk, scanclkena, scandata)
WITH ( AUTO_SETTINGS, BANDWIDTH, BANDWIDTH_TYPE, C0_HIGH, C0_INITIAL, C0_LOW, C0_MODE, C0_PH, C0_TEST_SOURCE, C1_HIGH, C1_INITIAL, C1_LOW, C1_MODE, C1_PH, C1_TEST_SOURCE, C1_USE_CASC_IN, C2_HIGH, C2_INITIAL, C2_LOW, C2_MODE, C2_PH, C2_TEST_SOURCE, C2_USE_CASC_IN, C3_HIGH, C3_INITIAL, C3_LOW, C3_MODE, C3_PH, C3_TEST_SOURCE, C3_USE_CASC_IN, C4_HIGH, C4_INITIAL, C4_LOW, C4_MODE, C4_PH, C4_TEST_SOURCE, C4_USE_CASC_IN, C5_HIGH, C5_INITIAL, C5_LOW, C5_MODE, C5_PH, C5_TEST_SOURCE, C5_USE_CASC_IN, c6_high, C6_INITIAL, C6_LOW, C6_MODE, C6_PH, C6_TEST_SOURCE, C6_USE_CASC_IN, c7_high, C7_INITIAL, C7_LOW, C7_MODE, C7_PH, C7_TEST_SOURCE, C7_USE_CASC_IN, c8_high, C8_INITIAL, C8_LOW, C8_MODE, C8_PH, C8_TEST_SOURCE, C8_USE_CASC_IN, c9_high, C9_INITIAL, C9_LOW, C9_MODE, C9_PH, C9_TEST_SOURCE, C9_USE_CASC_IN, CHARGE_PUMP_CURRENT, CHARGE_PUMP_CURRENT_BITS, CLK0_COUNTER, CLK0_DIVIDE_BY, CLK0_DUTY_CYCLE, CLK0_MULTIPLY_BY, CLK0_OUTPUT_FREQUENCY, CLK0_PHASE_SHIFT, CLK0_PHASE_SHIFT_NUM, clk0_use_even_counter_mode, clk0_use_even_counter_value, CLK1_COUNTER, CLK1_DIVIDE_BY, CLK1_DUTY_CYCLE, CLK1_MULTIPLY_BY, CLK1_OUTPUT_FREQUENCY, CLK1_PHASE_SHIFT, CLK1_PHASE_SHIFT_NUM, clk1_use_even_counter_mode, clk1_use_even_counter_value, CLK2_COUNTER, CLK2_DIVIDE_BY, CLK2_DUTY_CYCLE, CLK2_MULTIPLY_BY, CLK2_OUTPUT_FREQUENCY, CLK2_PHASE_SHIFT, CLK2_PHASE_SHIFT_NUM, clk2_use_even_counter_mode, clk2_use_even_counter_value, CLK3_COUNTER, CLK3_DIVIDE_BY, CLK3_DUTY_CYCLE, CLK3_MULTIPLY_BY, CLK3_OUTPUT_FREQUENCY, CLK3_PHASE_SHIFT, CLK3_PHASE_SHIFT_NUM, clk3_use_even_counter_mode, clk3_use_even_counter_value, CLK4_COUNTER, CLK4_DIVIDE_BY, CLK4_DUTY_CYCLE, CLK4_MULTIPLY_BY, CLK4_OUTPUT_FREQUENCY, CLK4_PHASE_SHIFT, CLK4_PHASE_SHIFT_NUM, clk4_use_even_counter_mode, clk4_use_even_counter_value, CLK5_COUNTER, CLK5_DIVIDE_BY, CLK5_DUTY_CYCLE, CLK5_MULTIPLY_BY, CLK5_OUTPUT_FREQUENCY, CLK5_PHASE_SHIFT, clk5_use_even_counter_mode, clk5_use_even_counter_value, CLK6_COUNTER, clk6_divide_by, clk6_duty_cycle, clk6_multiply_by, CLK6_OUTPUT_FREQUENCY, clk6_phase_shift, clk6_use_even_counter_mode, clk6_use_even_counter_value, CLK7_COUNTER, clk7_divide_by, clk7_duty_cycle, clk7_multiply_by, CLK7_OUTPUT_FREQUENCY, clk7_phase_shift, clk7_use_even_counter_mode, clk7_use_even_counter_value, CLK8_COUNTER, clk8_divide_by, clk8_duty_cycle, clk8_multiply_by, CLK8_OUTPUT_FREQUENCY, clk8_phase_shift, clk8_use_even_counter_mode, clk8_use_even_counter_value, CLK9_COUNTER, clk9_divide_by, clk9_duty_cycle, clk9_multiply_by, CLK9_OUTPUT_FREQUENCY, clk9_phase_shift, clk9_use_even_counter_mode, clk9_use_even_counter_value, CLKOUT_WIDTH = 7, COMPENSATE_CLOCK, DPA_DIVIDE_BY, DPA_DIVIDER, DPA_MULTIPLY_BY, ENABLE_SWITCH_OVER_COUNTER, INCLK0_INPUT_FREQUENCY, INCLK1_INPUT_FREQUENCY, LOCK_HIGH, LOCK_LOW, lock_window_ui, lock_window_ui_bits, LOOP_FILTER_C, LOOP_FILTER_C_BITS, LOOP_FILTER_R, LOOP_FILTER_R_BITS, M, M_INITIAL, M_PH, M_TEST_SOURCE, N, OPERATION_MODE, PFD_MAX, PFD_MIN, PHASECOUNTERSELECT_WIDTH = 4, PLL_COMPENSATION_DELAY, PLL_TYPE, SCAN_CHAIN_MIF_FILE, self_reset_on_loss_lock, SIMULATION_TYPE, SWITCH_OVER_COUNTER, SWITCH_OVER_TYPE, TEST_BYPASS_LOCK_DETECT, USE_DC_COUPLING, VCO_CENTER, VCO_DIVIDE_BY, vco_frequency_control, VCO_MAX, VCO_MIN, VCO_MULTIPLY_BY, vco_phase_shift_step, VCO_POST_SCALE, VCO_RANGE_DETECTOR_HIGH_BITS, VCO_RANGE_DETECTOR_LOW_BITS)
RETURNS ( activeclock, clk[CLKOUT_WIDTH-1..0], clkbad[1..0], fbout, locked, phasedone, scandataout, scandone, vcooverrange, vcounderrange);

--synthesis_resources = arriaii_pll 1 lut 13 reg 9 
OPTIONS ALTERA_INTERNAL_OPTION = "SUPPRESS_DA_RULE_INTERNAL=R101;SUPPRESS_DA_RULE_INTERNAL=C104;SUPPRESS_DA_RULE_INTERNAL=R101;{-to remap_decoy_le3a} ADV_NETLIST_OPT_ALLOWED = NEVER_ALLOW;{-to remap_decoy_le3a} IGNORE_LCELL_BUFFERS = OFF;{-to remap_decoy_le3a} REMOVE_REDUNDANT_LOGIC_CELLS = OFF;-name SDC_STATEMENT ""set_false_path -from ** -to *phasedone_state* "";-name SDC_STATEMENT ""set_false_path -from ** -to *internal_phasestep* """;

SUBDESIGN altpll_quo3
( 
	areset	:	input;
	clk[6..0]	:	output;
	inclk[1..0]	:	input;
	locked	:	output;
	phasecounterselect[3..0]	:	input;
	phasedone	:	output;
	phasestep	:	input;
	phaseupdown	:	input;
	scanclk	:	input;
) 
VARIABLE 
	altpll_dyn_phase_le2 : altpll_dyn_phase_le_jdo;
	altpll_dyn_phase_le4 : altpll_dyn_phase_le_kdo;
	altpll_dyn_phase_le5 : altpll_dyn_phase_le_ldo;
	altpll_dyn_phase_le6 : altpll_dyn_phase_le_mdo;
	internal_phasestep : dffe;
	phasedone_state : dffe;
	pll_internal_phasestep_reg : dffe;
	pll_lock_sync : dffe;
	remap_decoy_le3a[3..0] : lcell;
	phasestep_counter : cntr_hud;
	pll_internal_phasestep : cntr_nce;
	pll1 : arriaii_pll
		WITH (
			BANDWIDTH_TYPE = "auto",
			CLK0_DIVIDE_BY = 1,
			CLK0_DUTY_CYCLE = 50,
			CLK0_MULTIPLY_BY = 1,
			CLK0_PHASE_SHIFT = "833",
			CLK1_DIVIDE_BY = 1,
			CLK1_DUTY_CYCLE = 50,
			CLK1_MULTIPLY_BY = 2,
			CLK1_PHASE_SHIFT = "0",
			CLK2_DIVIDE_BY = 1,
			CLK2_DUTY_CYCLE = 50,
			CLK2_MULTIPLY_BY = 2,
			CLK2_PHASE_SHIFT = "0",
			CLK3_DIVIDE_BY = 1,
			CLK3_DUTY_CYCLE = 50,
			CLK3_MULTIPLY_BY = 2,
			CLK3_PHASE_SHIFT = "-1250",
			CLK4_DIVIDE_BY = 1,
			CLK4_DUTY_CYCLE = 50,
			CLK4_MULTIPLY_BY = 2,
			CLK4_PHASE_SHIFT = "0",
			CLK5_DIVIDE_BY = 1,
			CLK5_DUTY_CYCLE = 50,
			CLK5_MULTIPLY_BY = 2,
			CLK5_PHASE_SHIFT = "0",
			INCLK0_INPUT_FREQUENCY = 10000,
			OPERATION_MODE = "no_compensation",
			self_reset_on_loss_lock = "off",
			vco_frequency_control = "manual_phase",
			vco_phase_shift_step = 104
		);
	internal_phasestep_reg_wire	: WIRE;
	phasedone_low_counter[2..0]	: WIRE;
	phasedone_state_reg_wire	: WIRE;
	phasestep_counter_wire[1..0]	: WIRE;
	w16w[1..0]	: WIRE;
	w22w[2..0]	: WIRE;
	w31w[2..0]	: WIRE;

BEGIN 
	altpll_dyn_phase_le2.dataa = remap_decoy_le3a[0].out;
	altpll_dyn_phase_le2.datab = remap_decoy_le3a[1].out;
	altpll_dyn_phase_le2.datac = remap_decoy_le3a[2].out;
	altpll_dyn_phase_le2.datad = remap_decoy_le3a[3].out;
	altpll_dyn_phase_le4.dataa = remap_decoy_le3a[0].out;
	altpll_dyn_phase_le4.datab = remap_decoy_le3a[1].out;
	altpll_dyn_phase_le4.datac = remap_decoy_le3a[2].out;
	altpll_dyn_phase_le4.datad = remap_decoy_le3a[3].out;
	altpll_dyn_phase_le5.dataa = remap_decoy_le3a[0].out;
	altpll_dyn_phase_le5.datab = remap_decoy_le3a[1].out;
	altpll_dyn_phase_le5.datac = remap_decoy_le3a[2].out;
	altpll_dyn_phase_le5.datad = remap_decoy_le3a[3].out;
	altpll_dyn_phase_le6.dataa = remap_decoy_le3a[0].out;
	altpll_dyn_phase_le6.datab = remap_decoy_le3a[1].out;
	altpll_dyn_phase_le6.datac = remap_decoy_le3a[2].out;
	altpll_dyn_phase_le6.datad = remap_decoy_le3a[3].out;
	internal_phasestep.clk = scanclk;
	internal_phasestep.clrn = (! areset);
	internal_phasestep.d = (phasedone_state_reg_wire # ((((! phasedone_state_reg_wire) & phasedone_low_counter[2..2]) & w31w[1..1]) & phasedone_low_counter[0..0]));
	phasedone_state.clk = scanclk;
	phasedone_state.clrn = (! areset);
	phasedone_state.d = (((! phasedone_state_reg_wire) & ((phasedone_low_counter[0..0] & w22w[1..1]) & phasedone_low_counter[2..2])) # (phasedone_state_reg_wire & (w16w[0..0] # (phasestep_counter_wire[0..0] & phasestep_counter_wire[1..1]))));
	pll_internal_phasestep_reg.clk = scanclk;
	pll_internal_phasestep_reg.d = pll1.phasedone;
	pll_lock_sync.clk = pll1.locked;
	pll_lock_sync.clrn = (! areset);
	pll_lock_sync.d = B"1";
	remap_decoy_le3a[].in = ( phasecounterselect[3..0]);
	phasestep_counter.clock = scanclk;
	phasestep_counter.cnt_en = phasedone_state_reg_wire;
	pll_internal_phasestep.aclr = (areset # pll1.phasedone);
	pll_internal_phasestep.clock = scanclk;
	pll_internal_phasestep.cnt_en = (! pll_internal_phasestep_reg.q);
	pll1.areset = areset;
	pll1.fbin = pll1.fbout;
	pll1.inclk[] = inclk[];
	pll1.phasecounterselect[] = ( altpll_dyn_phase_le6.combout, altpll_dyn_phase_le5.combout, altpll_dyn_phase_le4.combout, altpll_dyn_phase_le2.combout);
	pll1.phasestep = (phasestep # internal_phasestep_reg_wire);
	pll1.phaseupdown = phaseupdown;
	pll1.scanclk = scanclk;
	clk[] = ( pll1.clk[6..0]);
	internal_phasestep_reg_wire = internal_phasestep.q;
	locked = (pll1.locked & pll_lock_sync.q);
	phasedone = (pll1.phasedone & (! internal_phasestep_reg_wire));
	phasedone_low_counter[] = pll_internal_phasestep.q[];
	phasedone_state_reg_wire = phasedone_state.q;
	phasestep_counter_wire[] = phasestep_counter.q[];
	w16w[] = (! phasestep_counter_wire[]);
	w22w[] = (! phasedone_low_counter[]);
	w31w[] = (! phasedone_low_counter[]);
END;
--VALID FILE
